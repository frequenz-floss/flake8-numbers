{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Flake8 Numbers Plugin","text":""},{"location":"#introduction","title":"Introduction","text":"<p>Flake8 Numbers Plugin</p> <p>This plugin ensures that large numbers of all bases are using digit seperators for improved readability.</p> <p>Some examples of well written numeric literals are:</p> <pre><code>good_float   = 123_456_789.123_456_789\ngood_hex     = 0xA_DEAD_BEEF\ngood_decimal = 10_000_000\ngood_binary  = 0b1010_1010_1010\n</code></pre>"},{"location":"#contributing","title":"Contributing","text":"<p>If you want to know how to build this project and contribute to it, please check out the Contributing Guide.</p>"},{"location":"CONTRIBUTING/","title":"Contributing to Flake Numbers Plugin","text":""},{"location":"CONTRIBUTING/#build","title":"Build","text":"<p>You can use <code>build</code> to simply build the source and binary distribution:</p> <pre><code>python -m pip install build\npython -m build\n</code></pre>"},{"location":"CONTRIBUTING/#local-development","title":"Local development","text":"<p>You can use editable installs to develop the project locally (it will install all the dependencies too):</p> <pre><code>python -m pip install -e .\n</code></pre> <p>Or you can install all development dependencies (<code>mypy</code>, <code>pylint</code>, <code>pytest</code>, etc.) in one go too: <pre><code>python -m pip install -e .[dev]\n</code></pre></p> <p>If you don't want to install all the dependencies, you can also use <code>nox</code> to run the tests and other checks creating its own virtual environments:</p> <pre><code>python -m pip install .[dev-noxfile]\nnox\n</code></pre> <p>You can also use <code>nox -R</code> to reuse the current testing environment to speed up test at the expense of a higher chance to end up with a dirty test environment.</p>"},{"location":"CONTRIBUTING/#running-tests-checks-individually","title":"Running tests / checks individually","text":"<p>For a better development test cycle you can install the runtime and test dependencies and run <code>pytest</code> manually.</p> <pre><code>python -m pip install .[dev-pytest]  # included in .[dev] too\n\n# And for example\npytest tests/test_*.py\n</code></pre> <p>Or you can use <code>nox</code>:</p> <pre><code>nox -R -s pytest -- test/test_*.py\n</code></pre> <p>The same appliest to <code>pylint</code> or <code>mypy</code> for example:</p> <pre><code>nox -R -s pylint -- test/test_*.py\nnox -R -s mypy -- test/test_*.py\n</code></pre>"},{"location":"CONTRIBUTING/#building-the-documentation","title":"Building the documentation","text":"<p>To build the documentation, first install the dependencies (if you didn't install all <code>dev</code> dependencies):</p> <pre><code>python -m pip install -e .[dev-mkdocs]\n</code></pre> <p>Then you can build the documentation (it will be written in the <code>site/</code> directory):</p> <pre><code>mkdocs build\n</code></pre> <p>Or you can just serve the documentation without building it using:</p> <pre><code>mkdocs serve\n</code></pre> <p>Your site will be updated live when you change your files (provided that you used <code>pip install -e .</code>, beware of a common pitfall of using <code>pip install</code> without <code>-e</code>, in that case the API reference won't change unless you do a new <code>pip install</code>).</p> <p>To build multi-version documentation, we use mike. If you want to see how the multi-version sites looks like locally, you can use:</p> <pre><code>mike deploy my-version\nmike set-default my-version\nmike serve\n</code></pre> <p><code>mike</code> works in mysterious ways. Some basic information:</p> <ul> <li><code>mike deploy</code> will do a <code>mike build</code> and write the results to your local <code>gh-pages</code> branch. <code>my-version</code> is an arbitrary name for the local version   you want to preview.</li> <li><code>mike set-default</code> is needed so when you serve the documentation, it goes to   your newly produced documentation by default.</li> <li><code>mike serve</code> will serve the contents of your local <code>gh-pages</code> branch. Be   aware that, unlike <code>mkdocs serve</code>, changes to the sources won't be shown   live, as the <code>mike deploy</code> step is needed to refresh them.</li> </ul> <p>Be careful not to use <code>--push</code> with <code>mike deploy</code>, otherwise it will push your local <code>gh-pages</code> branch to the <code>origin</code> remote.</p> <p>That said, if you want to test the actual website in your fork, you can always use <code>mike deploy --push --remote your-fork-remote</code>, and then access the GitHub pages produced for your fork.</p>"},{"location":"CONTRIBUTING/#releasing","title":"Releasing","text":"<p>These are the steps to create a new release:</p> <ol> <li> <p>Get the latest head you want to create a release from.</p> </li> <li> <p>Update the <code>RELEASE_NOTES.md</code> file if it is not complete, up to date, and    remove template comments (<code>&lt;!-- ... -&gt;</code>) and empty sections. Submit a pull    request if an update is needed, wait until it is merged, and update the    latest head you want to create a release from to get the new merged pull    request.</p> </li> <li> <p>Create a new signed tag using the release notes and    a semver compatible version number with a <code>v</code> prefix,    for example:</p> </li> </ol> <pre><code>git tag -s --cleanup=whitespace -F RELEASE_NOTES.md v0.0.1\n</code></pre> <ol> <li> <p>Push the new tag.</p> </li> <li> <p>A GitHub action will test the tag and if all goes well it will create    a GitHub    Release,    and upload a new package to    PyPI    automatically.</p> </li> <li> <p>Once this is done, reset the <code>RELEASE_NOTES.md</code> with the template:</p> </li> </ol> <pre><code>cp .github/RELEASE_NOTES.template.md RELEASE_NOTES.md\n</code></pre> <p>Commit the new release notes and create a PR (this step should be automated    eventually too).</p> <ol> <li>Celebrate!</li> </ol>"},{"location":"SUMMARY/","title":"SUMMARY","text":"<ul> <li>Home</li> <li>API Reference</li> <li>Contributing</li> </ul>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>flake8_numbers<ul> <li>check_numbers</li> </ul> </li> </ul>"},{"location":"reference/flake8_numbers/","title":"Index","text":""},{"location":"reference/flake8_numbers/#flake8_numbers","title":"<code>flake8_numbers</code>","text":"<p>Flake8 Numbers Plugin.</p>"},{"location":"reference/flake8_numbers/check_numbers/","title":"check_numbers","text":""},{"location":"reference/flake8_numbers/check_numbers/#flake8_numbers.check_numbers","title":"<code>flake8_numbers.check_numbers</code>","text":"<p>A flake8 plugin to check for numbers and their readability.</p>"},{"location":"reference/flake8_numbers/check_numbers/#flake8_numbers.check_numbers-classes","title":"Classes","text":""},{"location":"reference/flake8_numbers/check_numbers/#flake8_numbers.check_numbers.ErrorReport","title":"<code>flake8_numbers.check_numbers.ErrorReport</code>  <code>dataclass</code>","text":"<p>A class to represent an error report.</p> Source code in <code>src/flake8_numbers/check_numbers.py</code> <pre><code>@dataclass\nclass ErrorReport:\n    \"\"\"A class to represent an error report.\"\"\"\n\n    line: int\n    \"\"\"The line number of the error.\"\"\"\n\n    column: int\n    \"\"\"The column number of the error.\"\"\"\n\n    message: str\n    \"\"\"The error message.\"\"\"\n</code></pre>"},{"location":"reference/flake8_numbers/check_numbers/#flake8_numbers.check_numbers.ErrorReport-attributes","title":"Attributes","text":""},{"location":"reference/flake8_numbers/check_numbers/#flake8_numbers.check_numbers.ErrorReport.column","title":"<code>column: int</code>  <code>instance-attribute</code>","text":"<p>The column number of the error.</p>"},{"location":"reference/flake8_numbers/check_numbers/#flake8_numbers.check_numbers.ErrorReport.line","title":"<code>line: int</code>  <code>instance-attribute</code>","text":"<p>The line number of the error.</p>"},{"location":"reference/flake8_numbers/check_numbers/#flake8_numbers.check_numbers.ErrorReport.message","title":"<code>message: str</code>  <code>instance-attribute</code>","text":"<p>The error message.</p>"},{"location":"reference/flake8_numbers/check_numbers/#flake8_numbers.check_numbers.Flake8NumbersChecker","title":"<code>flake8_numbers.check_numbers.Flake8NumbersChecker</code>","text":"<p>class to represent a flake8 plugin to check for numbers and their readability.</p> Source code in <code>src/flake8_numbers/check_numbers.py</code> <pre><code>class Flake8NumbersChecker:\n    \"\"\"class to represent a flake8 plugin to check for numbers and their readability.\"\"\"\n\n    name = \"flake8.numbers\"\n    version = metadata.version(\"flake8-numbers\")\n    off_by_default = False\n\n    # Important: The parameter names must match exactly the way how flake8 expects them.\n    # This is sadly undocumented and we only found out by looking into the source code.\n    # But it is what it is.\n    def __init__(self, tree: ast.AST, filename: str) -&gt; None:\n        \"\"\"Initialize the checker.\n\n        Args:\n            tree: The AST of the file being checked.\n            filename: The path to the file being checked.\n        \"\"\"\n        self._tree = tree\n        self._filename = filename\n        self._source_lines: Optional[list[str]] = None\n\n    @property\n    def source_lines(self) -&gt; list[str]:\n        \"\"\"Get the source lines of the file being checked.\n\n        This value is cached on-demand.\n\n        Returns:\n            The source lines of the file being checked.\n        \"\"\"\n        if self._source_lines is None:\n            with open(self._filename, \"r\", encoding=\"utf-8\") as source_file:\n                self._source_lines = source_file.readlines()\n        return self._source_lines\n\n    def run(self) -&gt; Iterable[Tuple[int, int, str, Type[Any]]]:\n        \"\"\"Run the checker.\n\n        Yields:\n            A tuple of the form (line, column, message, type).\n        \"\"\"\n        for node in ast.walk(self._tree):\n            if isinstance(node, ast.Constant):\n                if result := self.check_constant(node):\n                    yield (\n                        result.line,\n                        result.column,\n                        result.message,\n                        Flake8NumbersChecker,\n                    )\n\n    def _extract_code(self, node: ast.AST) -&gt; str:\n        \"\"\"Extract the code of the given AST node.\n\n        Args:\n            node: The AST node to extract the code from.\n\n        Returns:\n            The code of the given AST node.\n        \"\"\"\n        start_line, start_col = node.lineno, node.col_offset\n        end_line, end_col = node.end_lineno, node.end_col_offset\n        original_code = \"\".join(\n            line[start_col:end_col].strip()\n            for line in self.source_lines[start_line - 1 : end_line]\n        )\n        return original_code\n\n    def _check_underscore_modulos(\n        self,\n        fragment: str,\n        original_literal: str,\n        modulo: int,\n        node: ast.Constant,\n    ) -&gt; Optional[ErrorReport]:\n        \"\"\"Check the given fragment for underscores at every modulo position.\n\n        Every part of the fragemnt that is separated by an underscore must be of length modulo.\n        The first part of the fragment is allowed to be shorter than modulo.\n\n        Args:\n            fragment: The fragment to check.\n            original_literal: The original literal that the fragment was extracted from.\n            modulo: The modulo to check for (e.g. 3 or 4).\n            node: The AST node to check.\n\n        Returns:\n            An ErrorReport if the fragment is not well formatted.\n        \"\"\"\n        parts = fragment.split(\"_\")\n        for i, part in enumerate(parts):\n            invalid_first_part = i == 0 and len(part) &gt; modulo\n            invalid_continuation_part = i != 0 and len(part) != modulo\n            if invalid_first_part or invalid_continuation_part:\n                message = (\n                    f\"NUM01: Use underscores every {modulo} digits in large numeric literals\"\n                    + f\" ({original_literal}) for better readability.\"\n                )\n                return ErrorReport(\n                    line=node.lineno,\n                    column=node.col_offset,\n                    message=message,\n                )\n\n        return None\n\n    def check_constant(self, node: ast.Constant) -&gt; Optional[ErrorReport]:\n        \"\"\"Check for the readability of the given numeric literal.\n\n        Args:\n            node: The AST node to check.\n\n        Returns:\n            An ErrorReport if the node is a number literal that is not well formatted.\n        \"\"\"\n        if type(node.value) not in (int, float):\n            return None\n\n        original_literal = self._extract_code(node)\n\n        # NB: We have to check for True and False here, because they are also of type\n        #     Constant, but are not numeric literals.\n        #     We cannot simply use ast.Num, because that was deprecated.\n        if original_literal in [\"True\", \"False\"]:\n            return None\n\n        base_value = _base_value(original_literal)\n        separator_modulo = _separator_modulo_for_base(base_value)\n        is_decimal = base_value == 10\n\n        is_science_notation = is_decimal and \"e\" in original_literal.lower()\n        is_float = \".\" in original_literal\n\n        parts: list[str] = []\n        if is_science_notation:\n            e_parts: list[str] = original_literal.split(\"e\")\n            frac_parts: list[str] = e_parts[0].split(\".\")\n            parts = frac_parts + [e_parts[1]]\n        elif is_float:\n            parts = original_literal.split(\".\")\n        elif not is_decimal:\n            parts = [original_literal[2:]]  # Remove the prefix\n        else:\n            parts = [original_literal]\n            # assert False, \"This should never happen\"\n\n        for part in parts:\n            if error := self._check_underscore_modulos(\n                part, original_literal, separator_modulo, node\n            ):\n                return error\n\n        return None\n</code></pre>"},{"location":"reference/flake8_numbers/check_numbers/#flake8_numbers.check_numbers.Flake8NumbersChecker-attributes","title":"Attributes","text":""},{"location":"reference/flake8_numbers/check_numbers/#flake8_numbers.check_numbers.Flake8NumbersChecker.source_lines","title":"<code>source_lines: list[str]</code>  <code>property</code>","text":"<p>Get the source lines of the file being checked.</p> <p>This value is cached on-demand.</p> RETURNS DESCRIPTION <code>list[str]</code> <p>The source lines of the file being checked.</p>"},{"location":"reference/flake8_numbers/check_numbers/#flake8_numbers.check_numbers.Flake8NumbersChecker-functions","title":"Functions","text":""},{"location":"reference/flake8_numbers/check_numbers/#flake8_numbers.check_numbers.Flake8NumbersChecker.__init__","title":"<code>__init__(tree, filename)</code>","text":"<p>Initialize the checker.</p> PARAMETER  DESCRIPTION <code>tree</code> <p>The AST of the file being checked.</p> <p> TYPE: <code>AST</code> </p> <code>filename</code> <p>The path to the file being checked.</p> <p> TYPE: <code>str</code> </p> Source code in <code>src/flake8_numbers/check_numbers.py</code> <pre><code>def __init__(self, tree: ast.AST, filename: str) -&gt; None:\n    \"\"\"Initialize the checker.\n\n    Args:\n        tree: The AST of the file being checked.\n        filename: The path to the file being checked.\n    \"\"\"\n    self._tree = tree\n    self._filename = filename\n    self._source_lines: Optional[list[str]] = None\n</code></pre>"},{"location":"reference/flake8_numbers/check_numbers/#flake8_numbers.check_numbers.Flake8NumbersChecker.check_constant","title":"<code>check_constant(node)</code>","text":"<p>Check for the readability of the given numeric literal.</p> PARAMETER  DESCRIPTION <code>node</code> <p>The AST node to check.</p> <p> TYPE: <code>Constant</code> </p> RETURNS DESCRIPTION <code>Optional[ErrorReport]</code> <p>An ErrorReport if the node is a number literal that is not well formatted.</p> Source code in <code>src/flake8_numbers/check_numbers.py</code> <pre><code>def check_constant(self, node: ast.Constant) -&gt; Optional[ErrorReport]:\n    \"\"\"Check for the readability of the given numeric literal.\n\n    Args:\n        node: The AST node to check.\n\n    Returns:\n        An ErrorReport if the node is a number literal that is not well formatted.\n    \"\"\"\n    if type(node.value) not in (int, float):\n        return None\n\n    original_literal = self._extract_code(node)\n\n    # NB: We have to check for True and False here, because they are also of type\n    #     Constant, but are not numeric literals.\n    #     We cannot simply use ast.Num, because that was deprecated.\n    if original_literal in [\"True\", \"False\"]:\n        return None\n\n    base_value = _base_value(original_literal)\n    separator_modulo = _separator_modulo_for_base(base_value)\n    is_decimal = base_value == 10\n\n    is_science_notation = is_decimal and \"e\" in original_literal.lower()\n    is_float = \".\" in original_literal\n\n    parts: list[str] = []\n    if is_science_notation:\n        e_parts: list[str] = original_literal.split(\"e\")\n        frac_parts: list[str] = e_parts[0].split(\".\")\n        parts = frac_parts + [e_parts[1]]\n    elif is_float:\n        parts = original_literal.split(\".\")\n    elif not is_decimal:\n        parts = [original_literal[2:]]  # Remove the prefix\n    else:\n        parts = [original_literal]\n        # assert False, \"This should never happen\"\n\n    for part in parts:\n        if error := self._check_underscore_modulos(\n            part, original_literal, separator_modulo, node\n        ):\n            return error\n\n    return None\n</code></pre>"},{"location":"reference/flake8_numbers/check_numbers/#flake8_numbers.check_numbers.Flake8NumbersChecker.run","title":"<code>run()</code>","text":"<p>Run the checker.</p> YIELDS DESCRIPTION <code>Iterable[Tuple[int, int, str, Type[Any]]]</code> <p>A tuple of the form (line, column, message, type).</p> Source code in <code>src/flake8_numbers/check_numbers.py</code> <pre><code>def run(self) -&gt; Iterable[Tuple[int, int, str, Type[Any]]]:\n    \"\"\"Run the checker.\n\n    Yields:\n        A tuple of the form (line, column, message, type).\n    \"\"\"\n    for node in ast.walk(self._tree):\n        if isinstance(node, ast.Constant):\n            if result := self.check_constant(node):\n                yield (\n                    result.line,\n                    result.column,\n                    result.message,\n                    Flake8NumbersChecker,\n                )\n</code></pre>"}]}